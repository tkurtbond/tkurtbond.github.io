<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lacking Natural Simplicity (Posts about poise)</title><link>https://tkurtbond.github.io/</link><description></description><atom:link href="https://tkurtbond.github.io/categories/poise.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2022 &lt;a href="mailto:tkurtbond@gmail.com"&gt;T. Kurt Bond&lt;/a&gt; </copyright><lastBuildDate>Thu, 24 Feb 2022 19:53:08 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>POISE DMS-PLus, a Description</title><link>https://tkurtbond.github.io/posts/2022/02/22/poise-dms-plus-a-description/</link><dc:creator>T. Kurt Bond</dc:creator><description>&lt;div&gt;&lt;p&gt;Some time ago I &lt;a class="reference external" href="https://tkurtbond.github.io/posts/2014/11/23/poise-dms-plus/"&gt;linked&lt;/a&gt; to a description of the POISE DMS-Plus, a Data
Management System that I've used extensively since the mid 1980s.
Last time I knew it was owned by Jenzabar.  Since Jenzabar's
description of it (as part of Jenzabar PX) has vanished from their web
pages I thought it would be useful to have a description of it on my
blog.&lt;/p&gt;
&lt;p&gt;I'll include &lt;a class="reference external" href="https://web.archive.org/web/20060313120910/http://www2.esp-tulsa.com/products.htm#dmsplus"&gt;Jenzabar's description&lt;/a&gt; of the POISE DMS-Plus here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DMS-Plus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each Jenzabar PX Administrative application module is built on
Jenzabar PX DMS-Plus®, a relational database management system (RDBMS)
using fourth-generation (4GL) language. DMS-Plus includes a powerful
report-writer, an information-retrieval system using multiple keys,
screen generation, and has multiple user levels: the operator,
intermediate user, advanced user, and application developers. It also
includes an Administrative Systems Query (ASQ or ask) language that is
designed to make the software easier to use for administrative
personnel. ASQ permits users to select, order, display, and print
information through simple English-like commands. In addition to ASQ,
another option for queries and reporting is QBF (Query By Form), a
point and select method which leads users through the data files and
query options.&lt;/p&gt;
&lt;p&gt;The benefits of a DMS-Plus approach to administrative processing
include ease of use by nontechnical personnel, a greater flexibility,
and speed and simplicity when implementing changes. It includes a
powerful data management and information retrieval facility with
right-to-use source code available. DMS-Plus includes list processing
as well as interfaces to stand-alone word processing systems. Future
enhancement to DMS-Plus are provided as part of the ongoing
subscription services. DMS-Plus is the common language for all types
of users.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;DMS-Plus Highlights&lt;/em&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;DMS-Plus provides Report Generators for easy sorting, selecting, and
printing along with Screen Generators for easy data entry, update,
and review.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DMS-Plus utilizes data manipulation for inserting, updating and
deleting data in the database. In addition to data definition for
adding new elements to the database, data control is also available
for accessing data by persons who have been granted access.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DMS-Plus has a menu processor, import/export capability via ASCII
file formats, a WordPerfect interface, and SQL compliant.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DMS-Plus is a user-oriented system that operates in a multi-user
environment. Simple English-like language prompts and responses are
used to interact with the system. By utilizing the flexibility of
DMS-Plus, each user office can determine the information collected,
can regulate work flow, can set its own schedules for updating
files, and can produce its own reports without depending on
Information System services.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DMS-Plus supports multi-user access. These application systems use
many of the same functions and techniques that provide continuity
across user departments and also allows cross-utilization of
personnel.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Many applications for information management needs may be
implemented through the software provided with little or no
additional programming.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DMS-Plus provides an integrated base of information for
administrative data processing. Information introduced into the
system may be carried forward into all appropriate areas without
redundant entry.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;While the above describes the POISE DMS-Plus as a “relational database
management system”, it isn't really.  It does not use a relational
database.  It comes from the time &lt;strong&gt;before&lt;/strong&gt; relational databases.&lt;/p&gt;
&lt;p&gt;To me, a database is a program that controls access to a collection of
data - you can’t get to the data without asking the database program
for it.&lt;/p&gt;
&lt;p&gt;A data management system (the DMS in DMS-Plus) just lets you associate
related data together, and then multiple programs can access the
pieces, usually using a standard API implemented as a library.&lt;/p&gt;
&lt;p&gt;Before the advent of Unix, files were often much more complicated that
just a stream of bytes.  For instance, under VMS (where I've used the
POISE DMS-Plus the most) the &lt;em&gt;Record Management Services&lt;/em&gt; (RMS)
provides sequential, relative, and indexed file organization, and
fixed-length and variable-length record formats, and allows you to
access records within these files sequentially, directly by key value,
directly by relative record number, or directly by record file
address.  It was common practice for programs to each use their own
specific mix of these aspects of RMS, with the details directly coded
into the program.&lt;/p&gt;
&lt;p&gt;The advantage of the POISE DMS-Plus is it provided a suite of programs
that worked together, allowing users to describe the format of the
files they wanted, enter and modify data in those files, sort and
select data, and produce nicely formatted reports, without having to
write any code.  The programs were interactive, issuing a series of
prompts to the user for what they needed to do next, and were very
easy to learn.  If a secretary wanted to keep track of the inventory
of their office, they would run &lt;span class="command"&gt;DMS:DESCRIBE&lt;/span&gt; to describe
the fields they wanted and allocate space for the file, then run
&lt;span class="command"&gt;DMS:ADD&lt;/span&gt; to add data, &lt;span class="command"&gt;DMS:SEARCH&lt;/span&gt; to search and
update it, &lt;span class="command"&gt;DMS:SORT&lt;/span&gt; to sort and select data, and
&lt;span class="command"&gt;DMS:PRINT&lt;/span&gt; to produce a nicely formatted report.  If they
had to do a lot of data entry into the file, or it was large or
complicated, they could run &lt;span class="command"&gt;DMS:SCREEN&lt;/span&gt; to define a text
user interface screen format for interactive user input, arranging the
fields or subsets of the fields on the screen to make data entry easy,
and then run &lt;span class="command"&gt;DMS:SCOPE&lt;/span&gt; using that screen format to do data
entry.  (I keep wishing for something as easy to use as
&lt;span class="command"&gt;DMS:SCREEN&lt;/span&gt; in the area of database backed web applications,
but haven't found it yet.)&lt;/p&gt;
&lt;p&gt;POISE DMS-Plus files &lt;em&gt;were&lt;/em&gt; relational in that it was possible for
fields in one file to refer to values in fields in another file,
similar to SQL &lt;code class="docutils literal"&gt;JOIN&lt;/code&gt;s and &lt;code class="docutils literal"&gt;FOREIGN KEY&lt;/code&gt; constraints.  So, for
instance, it was possible to have a code field in one file, but on
reports include the description of the code by pulling it from a code
file, keyed by the code field.&lt;/p&gt;
&lt;p&gt;All the POISE DMS-Plus programs used a documented API, the Support
Procedure Library, which programmers could use to write programs that
accessed POISE DMS-Plus files for applications that required
sophisticated, special purpose processing.  Furthermore, they
documented the file structures they used, so it was possible to write
programs that accessed DMS-Plus files directly, if necessary.&lt;/p&gt;
&lt;p&gt;POISE, by the way, stood for “People Oriented Interactive Software for
Education”, and it probably had its greatest success in systems for
education administration, but it was a general purpose tool and I have
worked on projects using it for many other areas, including local and
state government, real estate sales management, oil and gas royalty
management, and many others.&lt;/p&gt;&lt;/div&gt;</description><category>dms-plus</category><category>jenzabar px</category><category>poise</category><guid>https://tkurtbond.github.io/posts/2022/02/22/poise-dms-plus-a-description/</guid><pubDate>Tue, 22 Feb 2022 14:49:38 GMT</pubDate></item><item><title>POISE DMS-PLus</title><link>https://tkurtbond.github.io/posts/2014/11/23/poise-dms-plus/</link><dc:creator>T. Kurt Bond</dc:creator><description>&lt;div&gt;&lt;p&gt;I found a &lt;a class="reference external" href="http://www2.esp-tulsa.com/products.htm#dmsplus"&gt;web page&lt;/a&gt; that lists all the POISE products, now known as the
Jenzabar PX Administrative Information Systems, including the POISE
DMS-Plus.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2022-02-21 Update:&lt;/strong&gt; The link above is broken, but &lt;a class="reference external" href="https://archive.org/"&gt;archive.org&lt;/a&gt; has &lt;a class="reference external" href="https://web.archive.org/web/20060313120910/http://www2.esp-tulsa.com/products.htm#dmsplus"&gt;it&lt;/a&gt;!&lt;/p&gt;&lt;/div&gt;</description><category>dms-plus</category><category>jenzabar px</category><category>poise</category><guid>https://tkurtbond.github.io/posts/2014/11/23/poise-dms-plus/</guid><pubDate>Sun, 23 Nov 2014 06:48:58 GMT</pubDate></item><item><title>FILETAP</title><link>https://tkurtbond.github.io/posts/2004/01/09/2004-01-09/</link><dc:creator>T. Kurt Bond</dc:creator><description>&lt;div&gt;&lt;p&gt;I had to do some maintenance on the &lt;span class="app"&gt;FILETAP&lt;/span&gt; program today.
I last worked on it in 1988, as far as I can tell.  The last time it
was compiled was in 1990 (going by the file dates) but I doubt that
anybody had changed the code since 1988 when I last worked on it.
It's written to use the POISE SPL API, the Support Procedure Library.&lt;/p&gt;
&lt;p&gt;As it turned out, the only reason it needed recompiled now is that one
of MPL's POISE users finally found a use for field-and-record level
security and the enhanced security features only work if the program
is linked against the shared library (&lt;span class="file"&gt;.EXE&lt;/span&gt;) and not the statically
linked library (&lt;span class="file"&gt;.OLB&lt;/span&gt;).  And the program required no code changes to
get it to work.&lt;/p&gt;
&lt;p&gt;So where's the maintenance? It turns out that there are actually two
version of this program, &lt;span class="app"&gt;TFILETAP&lt;/span&gt; and &lt;span class="app"&gt;FILETAP&lt;/span&gt;,
and it's not obvious &lt;em&gt;why&lt;/em&gt; there are two versions.  &lt;span class="app"&gt;FILETAP&lt;/span&gt;
is the version that appears to be used the most, but
&lt;span class="app"&gt;TFILETAP&lt;/span&gt; is slightly different (mostly because it opens the
key file for exclusive access).  Unfortunately, as I've lamented
several times in the past, we weren't using any sort of revision
control back then, much less configuration control, so there is no
history of changes, much less an explicit reason for the changes.  Oh
well.  I guess I'll have to look at it some more later.&lt;/p&gt;&lt;/div&gt;</description><category>dms-plus</category><category>filetap</category><category>old blog</category><category>poise</category><category>spl</category><category>vms</category><guid>https://tkurtbond.github.io/posts/2004/01/09/2004-01-09/</guid><pubDate>Fri, 09 Jan 2004 05:00:00 GMT</pubDate></item><item><title>VMS Code from the Past</title><link>https://tkurtbond.github.io/posts/2003/05/08/2003-05-08-vms-code-from-the-past/</link><dc:creator>T. Kurt Bond</dc:creator><description>&lt;div&gt;&lt;p&gt;Listening to: Hawkwind, &lt;a class="reference external" href="http://www.freedb.org/freedb_search_fmt.php?cat=rock&amp;amp;id=d50ba50e"&gt;Chronicle of the Black Sword&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I've been reading a lot of VMS BASIC &lt;a class="footnote-reference brackets" href="https://tkurtbond.github.io/posts/2003/05/08/2003-05-08-vms-code-from-the-past/#id3" id="id1"&gt;1&lt;/a&gt; source code from the early
1990s &lt;a class="footnote-reference brackets" href="https://tkurtbond.github.io/posts/2003/05/08/2003-05-08-vms-code-from-the-past/#id4" id="id2"&gt;2&lt;/a&gt; recently, and the one lesson it has taught me is that
refactoring source code is vital for maintainability.  Much of this
source code originated in one program that was copied and edited
whenever a new program was needed, so each new program generally ended
up with a lot of rag-tag odds-and-ends code from the original program
that was not actually needed for the functionality of the new program.
Unfortunately, when one is trying to change some existing
functionality one has to look at each and every program &lt;em&gt;and figure
out if that functionality is actually implemented and used in that
program&lt;/em&gt;, and to do this you have to mentally trace the execution of
the code! The moral? When you copy code, delete everything you don't
actually use! Refactor, refactor, refactor!&lt;/p&gt;
&lt;p&gt;And why didn't we use &lt;code class="docutils literal"&gt;%INCLUDE&lt;/code&gt; more? There are hundress of lines of
external function declarations that are used time and again in several
programs; we should have put them in a couple of include files.&lt;/p&gt;
&lt;p&gt;I really wish VMS Basic allowed &lt;a class="reference external" href="http://groups.google.com/groups?q=tkb+group:comp.os.vms&amp;amp;hl=en&amp;amp;lr=&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;selm=a3db6b24.0305081211.6f867ad0%40posting.google.com&amp;amp;rnum=1"&gt;redimensioning array formal
parameters&lt;/a&gt;, but I understand why it's not allowed.  (Perhaps
there should have been a specific descriptor for arrays that can be
redimensioned?)&lt;/p&gt;
&lt;p&gt;I was shocked to rediscover that there was no way of reliably building
the system from the source code.  MMS was too expensive for us at the
time and if &lt;a class="reference external" href="http://www.madgoat.com/mmk.html"&gt;MMK&lt;/a&gt; existed we
didn't know about it.  We used a bunch of ad-hoc DCL command
procecudures to compile whatever program we were working on (most of
them were all in one source file, and linked against one library of
utility routines) and these were never collected.  So, you couldn't
easily tell if the current set of executables was actually built from
up-to-date source.  Since I've been doing the odd bit of maintenance on
this system every six months or so I finally broke down and created
&lt;code class="docutils literal"&gt;DESCRIP.MMS&lt;/code&gt; files for use with MMK, and I'm much easier in my mind
now.&lt;/p&gt;
&lt;p&gt;There were a number of things in this system that I think were well
done, though, so it hasn't been all pain looking at it again.&lt;/p&gt;
&lt;dl class="footnote brackets"&gt;
&lt;dt class="label" id="id3"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://tkurtbond.github.io/posts/2003/05/08/2003-05-08-vms-code-from-the-past/#id1"&gt;1&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;I'm working with it on an Alpha so I can't call it VAX BASIC
anymore.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class="label" id="id4"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="https://tkurtbond.github.io/posts/2003/05/08/2003-05-08-vms-code-from-the-past/#id2"&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;The original version of this system ran on PDP-11 running RSTS/E.
I've been involved in two major conversions of systems running on
PDP-11 RSTS/E to VAX/VMS, both using the POISE DMS-Plus on both RSTS/E and
VMS, with extensive homegrown applications written in VMS BASIC and
using the POISE SPL API.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;2014-11-03&lt;/h2&gt;
&lt;p&gt;Here's the text of my post to comp.os.vms:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The BASIC for OpenVMS Reference Manual says, in the fifth item of the
Remarks section:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The executable DIM statement cannot be used to dimension virtual arrays,
arrays received as formal parameters, or arrays declared in COMMON, MAP,
or nonexecutable DIM statements.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://h71000.www7.hp.com/doc/73final/cobol/bas_ref_013.htm#noisn"&gt;http://h71000.www7.hp.com/doc/73final/cobol/bas_ref_013.htm#noisn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The "no formal parameters" rule is inconvienent.  It means that you
can't pass an array to a function, redimension it, fill it with values,
and then use LBOUND and UBOUND in the caller to find out its new size.&lt;/p&gt;
&lt;p&gt;Presumably it is illegal because there is no way at compile time to
know if the function will be called with a dynamic array created with
the executable DIM statement or a static array created with a
non-executable DIM statement.&lt;/p&gt;
&lt;p&gt;However, the programmer &lt;em&gt;can&lt;/em&gt; know, so it ought to be safe to
redimension the array directly when the programmer knows it was
created by an executable DIM statement.&lt;/p&gt;
&lt;p&gt;Using Alpha BASIC V1.4-000 under OpenVMS V7.2 and looking at the
listing of some code with some executable dimension statements
compiled with /LIST/MACHINE revealed the existance of DBASIC$RT_DIM
and after a little experimentation lead to a program that used
DBASIC$RT_DIM directly to redimension dynamically dimensioned arrays
in functions, included below.&lt;/p&gt;
&lt;p&gt;DBASIC$RT_DIM is not documented for users (probably by design) and
could &lt;em&gt;theoretically&lt;/em&gt; lead to flying monkeys and access violations,
and is probably bad style.  However, are there any &lt;em&gt;practical&lt;/em&gt;
reasons why this wouldn't work safely?  Are there any
conditions under which this hack would fail to work?&lt;/p&gt;
&lt;p&gt;Here is an example program:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-1"&gt;&lt;/a&gt;program redim
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-2"&gt;&lt;/a&gt;    option type = explicit, constant type = integer, &amp;amp;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-3"&gt;&lt;/a&gt;        size = integer long, size = real double
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-4"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-5"&gt;&lt;/a&gt;    external sub redim_in_sub (string dim())
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-6"&gt;&lt;/a&gt;    external long function my_redim (string dim(), long)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-7"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-8"&gt;&lt;/a&gt;    declare long i, r
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-10"&gt;&lt;/a&gt;    i = 10
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-11"&gt;&lt;/a&gt;    dim string vs(i) ! has to be a variable to make it an executable dim.
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-13"&gt;&lt;/a&gt;    r = my_redim (vs(), 30)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-14"&gt;&lt;/a&gt;    print "ubound(vs):"; ubound(vs)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-15"&gt;&lt;/a&gt;    for i = lbound(vs) to ubound(vs) \ vs(i) = "vs 30-" + num1$(i) \ next i
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-16"&gt;&lt;/a&gt;    gosub print_vs
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-17"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-18"&gt;&lt;/a&gt;    call redim_in_sub (vs())
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-19"&gt;&lt;/a&gt;    print "ubound(vs):"; ubound(vs)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-20"&gt;&lt;/a&gt;    gosub print_Vs
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-21"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-22"&gt;&lt;/a&gt;    exit program
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-23"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-24"&gt;&lt;/a&gt;print_vs:
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-25"&gt;&lt;/a&gt;    for i = lbound(vs) to ubound(vs) \ print i; ": "; vs(i) \ next i
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-26"&gt;&lt;/a&gt;    return ! from print_vs
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-27"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-28"&gt;&lt;/a&gt;end program ! redim
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-29"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-30"&gt;&lt;/a&gt;function long my_redim (long s by value, long n)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-31"&gt;&lt;/a&gt;    option type = explicit, constant type = integer, &amp;amp;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-32"&gt;&lt;/a&gt;        size = integer long, size = real double
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-33"&gt;&lt;/a&gt;    declare long r
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-34"&gt;&lt;/a&gt;    external long function dbasic$rt_dim (long by value, long by value)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-35"&gt;&lt;/a&gt;    r = dbasic$rt_dim (s, n)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-36"&gt;&lt;/a&gt;end function r ! my_redim
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-37"&gt;&lt;/a&gt;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-38"&gt;&lt;/a&gt;sub redim_in_sub (string s())
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-39"&gt;&lt;/a&gt;    option type = explicit, constant type = integer, &amp;amp;
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-40"&gt;&lt;/a&gt;        size = integer long, size = real double
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-41"&gt;&lt;/a&gt;    external sub set_strings (string dim(), string)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-42"&gt;&lt;/a&gt;    declare long i
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-43"&gt;&lt;/a&gt;    call my_redim (s(), 40)
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-44"&gt;&lt;/a&gt;    for i = 0 to 40 \ s(i) = "redim in sub " + num1$(i) \ next i
&lt;a name="rest_code_ce86c513295147cebe1c0ed654468d2f-45"&gt;&lt;/a&gt;end sub ! redim_in_sub
&lt;/pre&gt;&lt;p&gt;(Interestingly, a slightly different approach was necessary using VAX
BASIC V3.5 under VMS V5.5-2: using BY VALUE in function
definition statements is not allowed by this version of VAX BASIC,
and BAS$RT_DIM had to be used instead of DBASIC$RT_DIM, of course.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>alpha</category><category>basic</category><category>dms-plus</category><category>hacks</category><category>mmk</category><category>old blog</category><category>poise</category><category>usenet</category><category>vax</category><category>vms</category><guid>https://tkurtbond.github.io/posts/2003/05/08/2003-05-08-vms-code-from-the-past/</guid><pubDate>Thu, 08 May 2003 05:00:00 GMT</pubDate></item></channel></rss>